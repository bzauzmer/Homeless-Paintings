<!DOCTYPE html>
<meta charset="utf-8">
<title>Homeless Paintings of the Italian Renaissance</title>
<style>

  body {
     font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
     font-weight: 300;    
     font-size: 10pt;
     background-color: #F0F0F0;
     /* was #d0ffff in case want to revert */
  }

  table {
    background-color: white;
    /* was #b0ffff in case want to revert */
  }

  .link {
    stroke: gray;
  }

  .node {
    stroke: #000;
    stroke-width: 0px;
  }

  .node:hover {
    fill: red !important;
  }

  a {text-decoration: underline;}
  a:link {color: #0000FF;}
  a:visited {color: #800080;}
  a:active {color: #FF0000;}

  .axis text {
  font: 10px sans-serif;
  }

  .axis path,
  .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
  }

  .bar rect{
    fill: steelblue;
  }

  .bar rect:hover {
    fill: brown;
  }

  .bar.tooltip {   
    position: absolute;           
    text-align: left;                      
    font: 12px;        
    background: lightgray;   
    border: 5px;      
    border-radius: 8px;           
    pointer-events: none;         
  }

  img {
    display: block;
    margin-left: auto;
    margin-right: auto
  }

  .line {
    fill: none;
    stroke: steelblue;
    stroke-width: 1.5px;
  }

  .centered {
    text-align: center;
  }

  .event {
    fill: #ff0000;
  }

</style>
<body>

<h4>
Homeless Paintings of the Italian Renaissance<br>
Jason Mahr, Linda Song, and Ben Zauzmer
<!--<br><br>
Art historian and Harvard graduate Bernard Berenson donated over 11,000 photographs of "homeless" paintings to Harvard upon his death.
These paintings have been lost, stolen, destroyed in World War II, etc.
The goal of this project is to visualize the collection, and perhaps even to help viewers find some of the paintings by filtering through the interactive data and using the Reverse Google Image Search link on the right side to hunt for lost art.-->
</h4>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://code.jquery.com/jquery-1.10.2.js"></script>
<script src="http://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>

  <form>
  Layout:
    <label><input type="radio" name="layout" value="force" checked> Force</label>
    <label><input type="radio" name="layout" value="radial"> Radial</label>
    <label><input type="radio" name="layout" value="map"> Map</label>
    <label><input type="radio" name="layout" value="timeline"> Timeline</label>
    <label><input type="radio" name="layout" value="wordcloud"> Word Cloud</label>
  </form>
  
    <table border="1">
    <tr>
      <td class="vis" rowspan="2"></td>
      <td class="filters" width="300" height="270">
        <p class="centered"><b>Filters:</b></p>
        Note: Due to the large size of this dataset (11,233 paintings), you must either choose years within a five-year period, choose a specific artist, or choose a specific city.
        <br>
        Start Date: 1300<input type="range" min="1300" max="1600" class="start" value="1300">1600
        <br>
        End Date: 1300<input type="range" min="1300" max="1600" class="end" value="1600">1600
        <br><br>
        Artist: 
        <div><input id="ArtistList" type="text" /></div>
      </td>
      <td class="focus"></td>
    </tr>
    <tr>
      <td class="bar" colspan="2">
      <!-- // making menu dropdown for the bar graph -->
      <p id="menu"><b>Bar Graph</b><br>Select series: <select>
        <option value="Artists">Artist vs Number of Paintings Missing</option>
        <option value="Years">Decade vs Number of Paintings Missing</option>
      </select>
      </td>
    </tr>
  </table>

<script>

//Margins, where bar_height is the height of the bar graph cell
// var width = 750, height = 500, bar_height = 200;
var width = 1280, height = 720, bar_height = 400;

// variables for the bar graph
var svg_barwidth = 500;

//making margins
var bar_margin = { top: 30, right: 40, bottom: 50, left: 50 };

//Create svg's for vis and bar
var svg_vis = d3.select(".vis").append("svg").attr("width", width).attr("height", height);
var svg_bar = d3.select(".bar").append("svg").attr("width", svg_barwidth).attr("height",bar_height);

//Create color scale for nodes
var colorScale = d3.scale.linear().domain([1300,1600]).range(["lightblue","blue"]);

//Add filler text to the non-vis cells
d3.select(".focus").append("p").attr("class", "centered").text("Click on a node!");

//JQuery for autocomplete
d3.csv("data.csv", function(data) {

  $(function () {  
    var artistList = $("#ArtistList").autocomplete({
      source: data.map(function (d) {return d.artist;}),
      change: function() { makevis(); }
    });
  });
});

//Create city filter label
d3.select(".filters").append("p").attr("class", "p_city").text("City:");

//Define cities
var cities = ['Bologna','Catania','Florence','Genoa','Messina','Milan','Naples','Padua','Palermo','Rome','Trieste','Turin','Venice','Verona'];

//Create drop-down for cities
d3.select(".p_city")
  .append("select")
  .attr("class","select_city")
  .selectAll("option")
  .data(cities)
  .enter()
  .append("option")
  .text(function (d) {return d;})
  .attr("value", function (d) {return d;});

//Makevis on initial page load
makevis();

//This is the main funciton that creates the visualization
function makevis() {

  //Remove all nodes, links, and dynamic drop-downs
  d3.selectAll(".node").remove();
  d3.selectAll(".link").remove();

  //Radio buttons should start with force checked
  d3.selectAll("input").each(function(d) {
    
    if (d3.select(this).attr("value") == 'force') {
     
      d3.select(this).node().checked = true;
    }
  });

  //Copy cities
  var cities_full = cities.slice(0);

  //Check if cities is allowed to have 'All'
  if (d3.select(".end").node().value - d3.select(".start").node().value <= 5 || $( "#ArtistList" ).val() != '') {

    //Remove 'All' from the list of cities
    d3.select(".all").remove();

    //Add 'All' to beginning of cities
    d3.select(".select_city")
      .append("option")
      .attr("class", "all")
      .text("All")
      .attr("value", "All");
  }
  else {
    
    //Remove 'All' from the list of cities
    d3.select(".all").remove();
  }

  //Create structure for force diagram
  var graph = {nodes:[], links:[]};

  // make an array of objects with the artist name and its corresponding number of missing paintings
  var artist_obj = [];
  var obj_array = [];

  // variable to hold max number of paintings an artist has
  var max_artist_number = 0;

  // variable to hold number of unique artists
  var artist_number = 0;

  //make an array of the dates total
  var date_array = [];
  var date_objarray = [];

  //make an array of the cities
  var city_obj = [];

  // make arrays for topic totals
  var topic_names = [];
  var topics_array = [];
  var topics_objarray = [];

  /* make an array for topics that also includes average
   * year of paintings that contain the topic
   */
  var topics_yrAvg = [];

  // array for median year, perhaps one is better than the other
  var topics_yrMed = [];

  // variables to store final arrays and maxes and mins
  var avg_max = 0,
      avg_min = 3014, /* Code will be fine for another 1000 years */
      med_max = 0,
      med_min = 3014;

  // know length of longest topic string, for accuracy of alphabetic scale later
  var topic_longestLength = 0;

  //Load data
  d3.csv("data.csv", function(data) {

    //Loop through paintings
    for (var i = 0; i < data.length; i++) {

      //Check if city matches selection
      if (d3.select(".select_city").node().value == 'All' || d3.select(".select_city").node().value == data[i]['city']) {

        //Check if artist matches selection
        if ($( "#ArtistList" ).val() == '' || $( "#ArtistList" ).val() == data[i]['artist']) {

          //Check if painting is in date range
          if (data[i]['date'] >= d3.select(".start").node().value && data[i]['date'] <= d3.select(".end").node().value) {

            //(Soon) Check if painting has selected topics
            // if (1==1) { if (1==1) { if (1==1) {

            //Add node for each painting
            graph.nodes.push({
              painting: data[i]['painting'],
              artist: data[i]['artist'],
              record: data[i]['record'],
              image: data[i]['image'],
              date: data[i]['date'],
              city: data[i]['city'],
              topics: data[i]['topics']
            });

            // if the artist isn't already in the array, create the counter to be set to 0
            if (!artist_obj[data[i]['artist']]) {
              artist_obj.push(artist_obj[data[i]['artist']] = 0);
              artist_number++;
            }

            var century = Math.floor(parseInt(data[i].date) / 100);

            // parse date
            if (!date_array[century]) {
              date_array.push(date_array[century] = 0);
            }

            // if the city isn't already in the array, create the counter to be set to 0
            if (data[i]['city'] && !city_obj[data[i]['city']]) {
              city_obj.push(city_obj[data[i]['city']] = 0);
            }

            // parse strings representing topic lists
            if (data[i].topics) {
              // to store list of topics for current painting in an array of strings; list is currently a string
              var ts = data[i].topics.slice(3,-2).split("', u'");

              // parse topics
              ts.forEach(function(t) {
                if (!topics_array[t]) {
                  topic_names.push(t);
                  topics_array.push(topics_array[t] = 1);
                  topic_longestLength = Math.max(t.length, topic_longestLength);
                  var parsedDate = parseInt(data[i].date);
                  topics_yrAvg.push(topics_yrAvg[t] = {total: parsedDate,
                    count: 1, average: parsedDate});
                  topics_yrMed.push(topics_yrMed[t] = [parsedDate]);
                  avg_max = Math.max(avg_max, parsedDate);
                  avg_min = Math.min(avg_min, parsedDate);
                } else {
                  ++topics_array[t];
                  var parsedDate = parseInt(data[i].date);
                  topics_yrAvg[t].total += parsedDate;
                  topics_yrAvg[t].count += 1;
                  topics_yrAvg[t].average =
                    topics_yrAvg[t].total/topics_yrAvg[t].count;
                  avg_max = Math.max(avg_max, topics_yrAvg[t].average);
                  avg_min = Math.min(avg_min, topics_yrAvg[t].average);
                  topics_yrMed[t].push(parsedDate);
                }
              });
            };

            // increase the counter by 1 per occurance
            ++artist_obj[data[i].artist];
            max_artist_number = Math.max(max_artist_number,artist_obj[data[i].artist]);
            ++date_array[century];

            if (data[i]['city']) {
              ++city_obj[data[i]['city']];
            }
          }
        }
      }
    }

    // to remove extraneous zeros
    for (var j = 0; j < artist_number; j++) {
      artist_obj.shift();
      city_obj.shift();
    }

    // to remove extraneous zeros for topic counts & averages
    var t_zerocount = topic_names.length;
    for (var k = 0; k < t_zerocount; k++) {
      topics_array.shift();
      topics_yrAvg.shift();
      topics_yrMed.shift();
    }

    // helper function to calculate median of any array
    var median = function(array) {
      array.sort(function(a,b) {return a - b;});
      var mid_index = Math.floor(array.length/2);
      if (array.length % 2) { return array[mid_index]; }
      else {return (array[mid_index - 1] + array[mid_index]) / 2.0;}
    }

    // simplify average array & calculate median so each topic maps to a number
    topic_names.forEach(function(topic) {
      topics_yrAvg[topic] = topics_yrAvg[topic].average;
      topics_yrMed[topic] = median(topics_yrMed[topic]);
      med_max = Math.max(med_max, topics_yrMed[topic]);
      med_min = Math.min(med_min, topics_yrMed[topic]);
    })

    // filtering out dup keys for artists
    for (artist in artist_obj) {
      obj_array.push({ artist: artist, value: artist_obj[artist] })
    }

    // filtering out dup keys for topics
    for (topic in topics_array) {
      topics_objarray.push({topic: topic, value: topics_array[topic]})
    }

    // To direct user to ABC sorting, & AND and OR boxes. LALALA (for ez nav)
    var manyZ = "";
    for (var i = 0; i < 100; i++) {
      // string with 100 Z characters, which will show where the max pixel is
      manyZ += "Z";
    }
    var nn = -6;  /* what's needed for these circles to have r = 8px */
    topics_objarray.push({topic: "A",value: nn,not_t: true});
    topics_objarray.push({topic: manyZ, value: nn,not_t: true});
    topics_objarray.push({topic: "A",value: nn,not_t: true,andor: 1});
    topics_objarray.push({topic: "N",value: nn,not_t: true,andor: 2});
    topics_objarray.push({topic: "D",value: nn,not_t: true,andor: 3});
    topics_objarray.push({topic: "O",value: nn,not_t: true,andor: 4});
    topics_objarray.push({topic: "R",value: nn,not_t: true,andor: 5});

    // parsing dates
    for (date in date_array) {
      date_objarray.push({ date: parseInt(date), value: date_array[date] });
    }

    //If drop-down or input is changed, makevis
    d3.selectAll("select").on("change", makevis);
    d3.selectAll(".start").on("change", makevis);
    d3.selectAll(".end").on("change", makevis);

    //Function that returns intersection of two arrays
    function intersect(a, b) {
      var t;
      if (b.length > a.length) t = b, b = a, a = t;
      return a.filter(function (e) {
          if (b.indexOf(e) !== -1) return true;
      });
    }

    //Loop through nodes
    for(var i = 0; i < graph.nodes.length; i++) {

      //Loop through nodes a second time for pairwise comparison
      for (var j = i + 1; j < graph.nodes.length; j++) {

        //Determine size of intersection
        var overlap = intersect(data[i]['topics'].slice(3,data[i]['topics'].length-2).split("', u'"),
          data[j]['topics'].slice(3,data[j]['topics'].length-2).split("', u'")).length;

        //Check if the nodes share any topics
        if (overlap) {

          //Add link if the nodes share a topic
          graph.links.push({"source": i, "target": j, "overlap": overlap});
        }
      }
    }

    //Create scale for timeline
    var yearScale = d3.scale.linear().domain([1300,1600]).range([100,width-100]);

    //Generate the force layout
    var force = d3.layout.force()
        .size([width, height])
        .charge(-50)
        .linkDistance(200)
        .on("tick", tick)
        .on("start", function(d) {})
        .on("end", function(d) {})

    //Part of the force layout
    function tick(d) {

      graph_update(0);
    }

    //Start force layout if radio button selected
    function force_layout() {

      //Delete map, text, x-axis, map circles, and word cloud
      svg_vis.select("image").remove();
      svg_vis.selectAll("text").remove();
      svg_vis.selectAll(".xaxis").remove();
      svg_vis.selectAll(".city").remove();
      svg_vis.selectAll(".absent").remove();
      svg_vis.selectAll(".event").remove();
      d3.selectAll(".word_cloud_structure").remove();
      d3.selectAll(".word_cloud_instructions").remove();
      d3.selectAll(".word_cloud_nodes").remove();

      //Reset nodes and links
      d3.selectAll("circle").attr("r",5);
      svg_vis.selectAll(".link").style("stroke-width", function(d) {return d.overlap;});

      //Start force
      force.nodes(graph.nodes)
          .links(graph.links)
          .start();
    }

    //Color nodes
    d3.selectAll(".node").style("fill", function (d) {return colorScale(d.date);});

    //Start radial layout if radio button selected
    function radial_layout() {

      //Stop force
      force.stop();

      //Delete map, text, x-axis, map circles, and word cloud
      svg_vis.select("image").remove();
      svg_vis.selectAll("text").remove();
      svg_vis.selectAll(".xaxis").remove();
      svg_vis.selectAll(".city").remove();
      svg_vis.selectAll(".absent").remove();
      svg_vis.selectAll(".event").remove();
      d3.selectAll(".word_cloud_structure").remove();
      d3.selectAll(".word_cloud_instructions").remove();
      d3.selectAll(".word_cloud_nodes").remove();

      //Reset nodes and links
      d3.selectAll("circle").attr("r",5);
      svg_vis.selectAll(".link").style("stroke-width", function(d) {return d.overlap;});

      // var r = height/2;
      var r = height - 50;
      var arc = d3.svg.arc().outerRadius(r);

      var pie = d3.layout.pie()
      .sort(function(a, b) { return a.cat - b.cat;})
              .value(function(d, i) { return 1; }); // equal share for each point

      graph.nodes = pie(graph.nodes).map(function(d, i) {
        d.innerRadius = 0;
        d.outerRadius = r;
        d.data.x = arc.centroid(d)[0] + width/2;
        d.data.y = arc.centroid(d)[1] + height/2;
        d.data.endAngle = d.endAngle; 
        d.data.startAngle = d.startAngle; 
        return d.data;
      })

      graph_update(500);
    }

    //Start map layout if radio button selected
    function map_layout() {

      //Stop force
      force.stop();

      //Delete x-axis, text, and word cloud
      svg_vis.selectAll(".xaxis").remove();
      svg_vis.selectAll("text").remove();
      svg_vis.selectAll(".event").remove();
      d3.selectAll(".word_cloud_structure").remove();
      d3.selectAll(".word_cloud_instructions").remove();
      d3.selectAll(".word_cloud_nodes").remove();

      //Add map of Italy
      var d_x = 400,
          d_y = 120,
          xdiff = 250;

      svg_vis.append('image')
        .attr("xlink:href", "Italy map.jpg")
        .attr("x", function() { return d_x.toString(); })
        .attr("y", function() { return d_y.toString(); })
        .attr("width", "500")
        .attr("height", "500");

      //Hide links
      svg_vis.selectAll(".link").style("stroke-width", 0);

      //Open coordinates json file
      d3.json("Coordinates.json", function(json) {

        //Loop through nodes
        for (var i = 0; i < node[0].length; i++) {

          //Check if node has city
          if (node[0][i]['__data__'].city) {

            //Set coordinates by city
            node[0][i]['__data__'].x = json[node[0][i]['__data__'].city].x + xdiff;
            node[0][i]['__data__'].y = json[node[0][i]['__data__'].city].y + d_y;
          }
        }

        //Hide nodes without cities
        svg_vis.selectAll("circle").attr("r",function (d) {if (d.city) {return 5;} else {return 0;}});

        //Create circles sized by city frequency
        svg_vis.selectAll(".city")
          .data(d3.entries(city_obj))
          .enter()
          .append("circle")
          .attr("class", "city")
          .attr("transform", function (d) {return "translate(" + (json[d.key].x+xdiff) + "," + (json[d.key].y+d_y) + ")";})
          .attr("r", function (d) {return 5 + d.value*0.5;})
          .attr("style", "fill: #0000ff");

        //Create black dots for cities not in data
        svg_vis.selectAll(".absent")
          .data(cities)
          .enter()
          .append("circle")
          .attr("class", "absent")
          .attr("transform", function (d) {return "translate(" + (json[d].x+xdiff) + "," + (json[d].y+d_y) + ")";})
          .attr("r", function (d) {if (Object.keys(city_obj).indexOf(d) > -1) {return 0} else {return 3};});

        //Add city labels (red if city has nodes)
        svg_vis.selectAll("text")
          .data(cities)
          .enter()
          .append("text")
          .text(function (d) {return d;})
          .attr("x", function (d) {return json[d].x + 8 + xdiff;})
          .attr("y", function (d) {return json[d].y + 5 + d_y;})
          .attr("style", function (d) {
            if (Object.keys(city_obj).indexOf(d) > -1) {
              return "fill: #ff0000"
            }
          });

        graph_update(500);

      });
    }

    //Start timeline layout if radio button selected
    function timeline_layout() {

      //Stop force
      force.stop();

      //Delete map, text, map circles, and word cloud
      svg_vis.select("image").remove();
      svg_vis.selectAll("text").remove();
      svg_vis.selectAll(".city").remove();
      svg_vis.selectAll(".absent").remove();
      svg_vis.selectAll(".event").remove();
      d3.selectAll(".word_cloud_structure").remove();
      d3.selectAll(".word_cloud_instructions").remove();
      d3.selectAll(".word_cloud_nodes").remove();

      //Reset nodes
      d3.selectAll("circle").attr("r",5);      

      //Hide links
      svg_vis.selectAll(".link").style("stroke-width", 0);

      //Loop through nodes
      for (var i = 0; i < node[0].length; i++) {

        //Move to timeline
        node[0][i]['__data__'].x = yearScale(node[0][i]['__data__'].date);
        node[0][i]['__data__'].y = 250;
      }

      //Define x-axis
      var xAxis = d3.svg.axis()
        .scale(yearScale)
        .orient("bottom")
        .ticks(6,"d")
        .tickSize(6,2);

      //Label for axis 1
      svg_vis.append("text")
        .text("Paintings:")
        .attr("transform", "translate(20,255)");

      //Label for axis 2
      svg_vis.append("text")
        .text("Events:")
        .attr("transform", "translate(20,405)");

      //Add x-axis
      svg_vis.append("g")
        .attr("class", "xaxis")
        .attr("transform", "translate(0,250)")
        .call(xAxis);

      //Add history timeline
      svg_vis.append("g")
        .attr("class", "xaxis")
        .attr("transform", "translate(0,400)")
        .call(xAxis);

      d3.csv('events.csv', function(data) {

        svg_vis.selectAll(".event")
          .data(data)
          .enter()
          .append("circle")
          .attr("class","event")
          .attr("transform", function (d) {return "translate(" + yearScale(d.Year) + "," + "400)";})
          .attr("r", 5)
          .append("svg:title")
            .text(function (d) {return d.Title + " (" + d.Year + ")\n" + d.Description;});
      });

      graph_update(500);
    }

    //To avoid excessive transitions
    var has_seen_word_cloud = false;

    //Start word cloud layout if radio button selected
    function wordcloud_layout() {

      // LALALA - color choice, durations, and delays
      choice = 2;
      var dur = 1000;
      var durations = [dur];
      var delays = has_seen_word_cloud ? [0,0,0,0,0,0,0,0,0,0,0,0] : 
        [0*dur,1*dur,2*dur,3*dur,4*dur,5*dur];

      has_seen_word_cloud = true;

      //User chose whether to use median or average
      var tendency_years = topics_yrMed,
          ty_min = med_min,
          ty_max = med_max;

      //Stop force
      force.stop();

      //Delete map, text, x-axis, map circles, and word cloud
      svg_vis.select("image").remove();
      svg_vis.selectAll("text").remove();
      svg_vis.selectAll(".xaxis").remove();
      svg_vis.selectAll(".city").remove();
      svg_vis.selectAll(".absent").remove();
      svg_vis.selectAll(".event").remove();
      d3.selectAll(".word_cloud_structure").remove();
      d3.selectAll(".word_cloud_instructions").remove();
      d3.selectAll(".word_cloud_nodes").remove();

      // padding for toolbox
      var toolbox = 99.5;

      // padding from margins for visualization
      var t_padding = 50;

      // adjusted bottom margin
      var t_bottom = t_padding + Math.round(toolbox);

      // horizontal midpoint of screen
      var midpoint = width / 2;

      //Make page look like the way I want it to
      // word_cloud_structure
      var pixels_between_lines = 3;
      var space_for_boxes = 120.5;

      // four horizontal lines
      svg_vis.append("line")
        .attr("x1",0)
        .attr("y1",height - toolbox - pixels_between_lines)
        .attr("x2",midpoint - (space_for_boxes - pixels_between_lines))
        .attr("y2",height - toolbox - pixels_between_lines)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      svg_vis.append("line")
        .attr("x1",0)
        .attr("y1",height - toolbox)
        .attr("x2",midpoint - space_for_boxes)
        .attr("y2",height - toolbox)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      svg_vis.append("line")
        .attr("x1",midpoint + (space_for_boxes - pixels_between_lines))
        .attr("y1",height - toolbox - pixels_between_lines)
        .attr("x2",width)
        .attr("y2",height - toolbox - pixels_between_lines)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      svg_vis.append("line")
        .attr("x1",midpoint + space_for_boxes)
        .attr("y1",height - toolbox)
        .attr("x2",width)
        .attr("y2",height - toolbox)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      // four vertical lines
      svg_vis.append("line")
        .attr("x1",midpoint - space_for_boxes)
        .attr("y1",height - toolbox)
        .attr("x2",midpoint - space_for_boxes)
        .attr("y2",height)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      svg_vis.append("line")
        .attr("x1",midpoint - (space_for_boxes - pixels_between_lines))
        .attr("y1",height - toolbox - pixels_between_lines)
        .attr("x2",midpoint - (space_for_boxes - pixels_between_lines))
        .attr("y2",height)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      svg_vis.append("line")
        .attr("x1",midpoint + (space_for_boxes - pixels_between_lines))
        .attr("y1",height - toolbox - pixels_between_lines)
        .attr("x2",midpoint + (space_for_boxes - pixels_between_lines))
        .attr("y2",height)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      svg_vis.append("line")
        .attr("x1",midpoint + space_for_boxes)
        .attr("y1",height - toolbox)
        .attr("x2",midpoint + space_for_boxes)
        .attr("y2",height)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      // two move vertical lines
      svg_vis.append("line")
        .attr("x1",midpoint - (pixels_between_lines/2))
        .attr("y1",height - toolbox - pixels_between_lines)
        .attr("x2",midpoint - (pixels_between_lines/2))
        .attr("y2",height)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      svg_vis.append("line")
        .attr("x1",midpoint + (pixels_between_lines/2))
        .attr("y1",height - toolbox - pixels_between_lines)
        .attr("x2",midpoint + (pixels_between_lines/2))
        .attr("y2",height)
        .attr("class","word_cloud_structure")
        .attr("stroke","black")
        .attr("stroke-width",0)
        .transition().duration(durations[0]).delay(delays[3])
          .attr("stroke-width",1);

      //Hide nodes and links
      d3.selectAll("circle").attr("r",0);
      svg_vis.selectAll(".link").style("stroke-width", 0);

      // instructions for user
      var instructions = "There are " + t_zerocount + " topics. " +
        "Topics are listed alphabetically. " +
        "Drag multiple topics into the black box to view paintings containing " +
        "all of your selected topics.";

      // show instructions for user
      svg_vis.append("text")
        .text(instructions)
        .style("fill","steelblue")
        .attr("font-style","italic")
        .attr("font-size","0px")
        .attr("class","word_cloud_instructions")
        .attr("transform","translate(168,15)")
        .transition().duration(durations[0]).delay(delays[0])
          .attr("font-size","15px");

      // color scale based on average
      // var color = d3.scale.linear()
      //   .domain([avg_min, avg_max])
      //   .range(["blue","red"]);

      // color functions based on median or average, or random colors
      var color = [
        (/* Ocean */
        d3.scale.linear().domain([ty_min, ty_max]).range(["#DDFFFF","#105E5F"])),
        (/* Fire */
        d3.scale.linear().domain([ty_min, ty_max]).range(["#9F000F","#FFE82C"])),
        (/* Water */
        d3.scale.linear().domain([ty_min, ty_max]).range(["#2554C7","#92DAFF"])),
        (/* Random colors, borrowed from goo.gl/Tru4Dj */
        function(d) {
          var letters = '0123456789ABCDEF'.split('');
          var color = '#';
          for (var i = 0; i < 6; i++ ) {
            color += letters[Math.floor(Math.random() * 16)];
          } 
          return color;
        })];

      // to store adjusted width, which is width - 2 * padding
      var adjusted_width = width - 2 * t_padding;

      // maximum pixel, considering the current height, width, and padding
      var max_pixel = adjusted_width * (height - t_padding - t_bottom);

      // a helper function that converts a string with a single letter of the alphabet to a number between 1 and 26
      var toNumber = function(c) {
        var n = 0;
        if (c==" ") {n=0;}
        else if (c=="a" || c=="A") {n=1;}    else if (c=="b" || c=="B") {n=2;}
        else if (c=="c" || c=="C") {n=3;}    else if (c=="d" || c=="D") {n=4;}
        else if (c=="e" || c=="E") {n=5;}    else if (c=="f" || c=="F") {n=6;}
        else if (c=="g" || c=="G") {n=7;}    else if (c=="h" || c=="H") {n=8;}
        else if (c=="i" || c=="I") {n=9;}    else if (c=="j" || c=="J") {n=10;}
        else if (c=="k" || c=="K") {n=11;}   else if (c=="l" || c=="L") {n=12;}
        else if (c=="m" || c=="M") {n=13;}   else if (c=="n" || c=="N") {n=14;}
        else if (c=="o" || c=="O") {n=15;}   else if (c=="p" || c=="P") {n=16;}
        else if (c=="q" || c=="Q") {n=17;}   else if (c=="r" || c=="R") {n=18;}
        else if (c=="s" || c=="S") {n=19;}   else if (c=="t" || c=="T") {n=20;}
        else if (c=="u" || c=="U") {n=21;}   else if (c=="v" || c=="V") {n=22;}
        else if (c=="w" || c=="W") {n=23;}   else if (c=="x" || c=="X") {n=24;}
        else if (c=="y" || c=="Y") {n=25;}   else {n=26;}
        return n;
      }

      // I am organizing alphabetically to the accuracy of accuracy letters
      var accuracy = topic_longestLength;

      // Last possible string
      var zstring = "";
      for (i = 0; i < accuracy; i++) {
        zstring += "z";
      }

      // a helper function to add accuracy to the end of any string
      var add_spaces = function(str) {
        for (i = 0; i < accuracy; i++) {
          str += " ";
        }
        return str;
      }

      // an array which contains the necessary powers of 26 for accuracy
      var powers = [];
      for (i = accuracy - 1; i >= 0; i--) {
        powers.push(Math.pow(26,i));
      }

      /* a helper function to alphabetically convert any string to a number b/w
       * 1 (a) and 11881376 (which is 26*26^4 + 26*26^3 + 26*26^2 + 26*26^1 +
       * 26*26^0 = 12356630 and represents zzzzz). Max will change depending on
       * what accuracy is set to.
       */
      var toTotal = function(str) {

        // so there is no error if the string is too short
        var s = add_spaces(str);

        // variable for running total
        var total = 0;
        
        // convert string to number between 1 and 12356630
        for (var i = 0; i < accuracy; i++) {
          total += toNumber(s.slice(i,i+1)) * powers[i];
        }

        // return result
        return total;
      }

      // a scale so that a is in top-left and zstring is in bottom-right, did not use "" as top-left because no topic starts with a space.
      var alphaScale = d3.scale.linear()
        .domain([toTotal("a"),toTotal(zstring)])
        .range([1,max_pixel]);

      // bind data to nodes
      var tnodes = svg_vis.selectAll("g topic")
        .data(topics_objarray)

      // positions for AND and OR LALALA
      var dist_ctr = 11;
      var init_and = 4;
      var init_or = 8;
      var dist_circ = 15;
      var andor_pos = ["",
        {x: (midpoint-dist_ctr), y: (height-(toolbox-init_and))},
        {x: (midpoint-dist_ctr), y: (height-(toolbox-(dist_circ+init_and)))},
        {x: (midpoint-dist_ctr), y: (height-(toolbox-(2*dist_circ+init_and)))},
        {x: (midpoint+dist_ctr), y: (height-(dist_circ+init_or))},
        {x: (midpoint+dist_ctr), y: (height-init_or)}
      ]

      // append groups
      var tnodesEnter = tnodes.enter()
        .append("g")
        .attr("class",function(d) {
          return (d.not_t) ? "word_cloud_structure" : "word_cloud_nodes";
        })
        .attr("transform", function(d) {
          if (d.andor) {
            d["x"] = andor_pos[d.andor].x;
            d["y"] = andor_pos[d.andor].y;
            d["orig_x"] = d.x;
            d["orig_y"] = d.y;
            return "translate(" + d.x + "," + d.y + ")";
          } else {
            var pixel_number = Math.round(alphaScale(toTotal(d.topic)));
            var unadjusted_x = pixel_number % adjusted_width;
            d["x"] = unadjusted_x ? unadjusted_x + t_padding - 1 : width - t_padding;
            d["y"] = (Math.floor(pixel_number / adjusted_width) + t_padding);
            d["orig_x"] = d.x;
            d["orig_y"] = d.y;
            return "translate(" + d.x + "," + d.y + ")";
          }
        });

      // min & max radius of circle for the sake of usability
      var min_radius = 14, /* absolute min for 5px nodes. */
          max_radius = 70,
          r_incr = 1;

      // append circle to group
      var tcircle = tnodesEnter.append("circle")
        .attr("r",0)
        // 0 = Ocean, 1 = Fire, 2 = Water, 3 = Random, decide average or median up there ^
        .attr("class", function(d) { return (d.not_t) ? "nT" : "isT_circle"; })
        .style("fill", function(d) { return color[choice](tendency_years[d.topic]);})
        .transition().duration(durations[0]).delay(function(d) {
          return delays[(d.not_t) ? 4 : 1];
        })
          .attr("r", function(d) {
            d["r"] = Math.min(min_radius + d.value * r_incr, max_radius);
            d["move_r"] = 1.5 * d.r;
            return d.r;
          });

      // append text to group
      tnodesEnter.append("text")
        .attr("dy", function(d) { return (d.not_t) ? "4px" : ".3em"; })
        .attr("class", function(d) { return (d.not_t) ? "nT" : "isT_text"; })
        .style("fill", function(d) { return (d.not_t) ? "white" : "black"; })
        .text(function(d) {
          if (d.not_t) { return d.topic.charAt(0); } else {
          d["label"] = d.topic.replace(/([a-zA-Z ,]+)(.*)/,'$1');
          return d.label; }
        })
        .style("text-anchor","middle")
        .attr("font-size","0px")
        .transition().duration(durations[0]).delay(function(d) {
          return delays[(d.not_t) ? 5 : 2];
        })
          .attr("font-size", "12px");

      // function so that circles can move
      var move_circle = d3.behavior.drag()
        .origin(function(d) {
          return {x: d.x, y: d.y}; })
        .on("dragstart",dragstarted)
        .on("drag", dragged)
        .on("dragend", dragended);

      // call move_circle
      tnodesEnter.call(move_circle);

      // expand circle when group is clicked
      function dragstarted(d) {
        d3.select(this).transition()
            .ease("elastic")
            .duration(500)
            .select(".isT_circle")
            .transition().duration(500).delay(0)
              .attr("r", d.move_r);
        d3.select(this).transition()
            .select(".isT_text")
            .transition().duration(500).delay(0)
              .attr("font-size", "18px");
      }

      // move group when it is dragged
      function dragged(d) {
        d.x = d3.event.x;
        d.y = d3.event.y;

        d3.select(this)
            .attr("transform", function(d) {
              if (!d.not_t) { return "translate(" + d.x + "," + d.y + ")"; }
              else { return "translate(" + d.orig_x + "," + d.orig_y + ")"; }
            });

        // here can have gradient change from concave to convex if circle is in box, or circle is hovering over!
      }

      // shrink circle back to original size when group is released
      function dragended(d) {
        d3.select(this).transition()
            .ease("elastic")
            .duration(500)
            .select(".isT_circle")
            .transition().duration(500).delay(0)
              .attr("r", d.r);
        d3.select(this).transition()
            .select(".isT_text")
            .transition().duration(500).delay(0)
              .attr("font-size", "12px");

        // RIGHT HERE IS A POWEFUL PLACE
        /* can check if any circles are in the AND or OR slots
           can check if anything was moved off the screen and respawn it in its correct location based on user's choice bw the two options
              - can record in an array a STACK of deleted items
           can keep a RUNNING ARRAY of circles in each box. whenever something is dropped, if the new x,y is in the box, then add that circle to the array if it's not already there. if the new x,y is not, then REMOVE the circle from the array if it is there.
         */
      }

      // update graph
      graph_update(500);
    }

    //Update graph via smooth transition
    function graph_update(delay) {

      //Transition links
      link.transition().duration(delay)
          .attr("x1", function(d) { return d.target.x; })
          .attr("y1", function(d) { return d.target.y; })
          .attr("x2", function(d) { return d.source.x; })
          .attr("y2", function(d) { return d.source.y; });

      //Transition nodes
      node.transition().duration(delay)
          .attr("transform", function(d) { 
            return "translate("+d.x+","+d.y+")"; 
          });
    }

    //Enable radio buttons
    d3.select("input[value=\"force\"]").on("click", force_layout);
    d3.select("input[value=\"radial\"]").on("click", radial_layout);
    d3.select("input[value=\"map\"]").on("click", map_layout);
    d3.select("input[value=\"timeline\"]").on("click", timeline_layout);
    d3.select("input[value=\"wordcloud\"]").on("click", wordcloud_layout);

    //Create nodes
    var node = svg_vis.selectAll(".node")
                  .data(graph.nodes)
                .enter()
                  .append("g").attr("class", "node");

    //Create links
    var link = svg_vis.selectAll(".link")
                .data(graph.links)
                .enter().insert("svg:line","g.node")
                .attr("class", "link")
                //Link thickness by number of overlapping topics
                .style("stroke-width", function(d) {return d.overlap;});

    //Add circles to nodes
    node.append("circle")
        .attr("r", 5)
        .on('click', function(d) {

          //Text-align left once first node is clicked
          d3.select(".focus").style("text-align", "left");
          d3.selectAll(".focus text").remove();

          //Remove previous image and text from focus
          d3.select(".focus img").remove();
          d3.selectAll(".focus p").remove();

          //Add clicked image to focus
          d3.select(".focus").append("img")
            .attr("src",d.image)
            .style("text-align", "center")
            .attr("width",125)
            .attr("height",125);

          //Add clicked text to focus
          d3.select(".focus").append("p").text("Painting: " + d.painting);
          d3.select(".focus").append("p").text("Artist: " + d.artist);
          d3.select(".focus").append("p").text("Record number: " + d.record);
          d3.select(".focus").append("p").text("Year: " + d.date);
          d3.select(".focus").append("p").append("a").attr("href", "http://images.google.com/searchbyimage?image_url=" + d.image).attr("target","_blank")
            .text("Reverse Image Search");

        })
        //Tooltip on hover
        .append("svg:title")
          .text(function(d) { return "Painting: " + d.painting + "\nArtist: " + d.artist + "\nRecord number: " + d.record; });

    //Default layout is force
    force_layout();

    // generates bar graph depending on the value of the chosen dropdown menu
    function generateBarGraph() {

      // making an array to hold only the number of missing paintings per artist
      var paintingsMissing = [];
      var artists_array = [];

      // looping through the missing paintings count array to push the number of paintings missing regardless of artist into an array
      for(var artist in artist_obj) {
        paintingsMissing.push(artist_obj[artist]);
        artists_array.push(artist);
      }

      // clear the current graph 
      d3.selectAll("rect").remove()
      d3.selectAll(".bar").selectAll("text").remove()
      d3.selectAll(".x.axis").remove()
      d3.selectAll(".y.axis").remove()
      d3.selectAll(".tooltip").remove()

      var series = menu.property("value");

      if (series == "Artists") {
        createArtistMissing(artists_array, paintingsMissing);
      } else if (series == "Years") {
        createDecadeMissing(artists_array, paintingsMissing);
      }
    } 

    // creates bar graph (artist vs painting)
    function createArtistMissing(artists_array, paintingsMissing) {

      // making the scales 
      var x = d3.scale.ordinal()
        .domain(artists_array)
        .rangeRoundBands([bar_margin.right, svg_barwidth], .1)

      var y = d3.scale.linear()
        .domain([0, d3.max(paintingsMissing)])
        .range([bar_height - bar_margin.bottom,10])

      // making the axes
      var xAxis = d3.svg.axis()
          .scale(x)
          .orient("bottom");

      var yAxis = d3.svg.axis()
          .scale(y)
          .orient("left")
          .ticks([max_artist_number])

      // for tooltip
      var div = d3.select(".bar").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

      // rotating the labels on the x axis
      svg_bar.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + (bar_height - bar_margin.bottom) + ")")
          .call(xAxis)
          .selectAll("text")  
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", function() {
              if (artist_number > 40) { return "100px"; }
              else { return ".15em"; }})
            .attr("transform", "rotate(-65)");

      // y axis made
      svg_bar.append("g")
          .attr("class", "y axis")
          .attr("transform", "translate(" + bar_margin.right + ",0)" )
          .call(yAxis)
          .append("text")
          .style("text-anchor", "end")
          .text("Missing Paintings")
            .attr("transform", "rotate(-90)");

      // creating the bars themselves
      svg_bar.selectAll(".bar")
          .data(obj_array)
        .enter().append("rect")
          .attr("class", "bar")
          .attr("x", function(d) { return x(d.artist); })
          .attr("y", function(d) { return y(d.value); })
          .attr("height", function(d) { return bar_height - y(d.value) - bar_margin.bottom; })
          .attr("width", x.rangeBand())
          .attr("opacity", .9)

          // for mouseover details
          .on("mouseover", function(d) {
            div.transition()
              .duration(200)
              .style("opacity", .9);
            div.html("<b>" + "Artist: " + "</b>" + d.artist + "<br>")
              .style("left", (d3.event.pageX) + "px")
              .style("top", (d3.event.pageY - 28) + "px");
          })
          .on("mouseout", function(d) {
            div.transition()
              .duration(500)
              .style("opacity", 0);
          })
    }

    // function that updates the graph to linear vs linear bar graph
    function createDecadeMissing(artists_array, paintingsMissing) {
      console.log(date_array);
      console.log(date_objarray);

      // making the linear scales
      var x = d3.scale.linear()
        .domain(d3.extent(Object.keys(date_array)))
        .range([bar_margin.right, svg_barwidth])

      var y = d3.scale.linear()
        .domain([0, d3.max(date_array)])
        .range([bar_height - bar_margin.bottom,10])

      // creating the axes
      var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")

      var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")

      // for tooltip
      var div = d3.select(".bar").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

      svg_bar.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + (bar_height - bar_margin.bottom) + ")")
          .call(xAxis)
          .append("text")  
          .style("text-anchor", "end")
          .text("Decade");

      svg_bar.append("g")
          .attr("class", "y axis")
          .attr("transform", "translate(" + bar_margin.right + ",0)" )
          .call(yAxis)
          .append("text")
          .style("text-anchor", "end")
          .text("Missing Paintings")
            .attr("transform", "rotate(-90)");

      svg_bar.selectAll(".bar")
          .data(date_objarray)
        .enter().append("rect")
          .attr("class", "bar")
          .attr("x", function(d) { return x(d.date); })
          .attr("y", function(d) { return y(d.value); })
          .attr("height", function(d) { return bar_height - y(d.value) - bar_margin.bottom; })
          .attr("width", (svg_barwidth - bar_margin.left)/(date_objarray.length))

        // for mouseover details
        .on("mouseover", function(d) {
          div.transition()
            .duration(200)
            .style("opacity", .9);
          div.html("<b>" + "Date: " + "</b>" + (d.date + 1) + "th century" + "<br>")
            .style("left", (d3.event.pageX) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
        })
        .on("mouseout", function(d) {
          div.transition()
            .duration(500)
            .style("opacity", 0);
        })
    }

    // update bar graph when menu selection is changed    
    var menu = d3.select("#menu select")
    .on("change", generateBarGraph); 

    generateBarGraph();

  })
}
</script>
</body>
</html>